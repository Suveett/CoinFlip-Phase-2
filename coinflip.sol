pragma solidity 0.5.12;

import "./provableAPI.sol";
import { SafeMath } from "./SafeMath.sol";


contract Coinflip is usingProvable{

  using SafeMath for uint;

  //Events to listen for :
  event RandomNumberGenerated(uint randomNumber);
  event LogNewProvableQuery(address indexed player);
  event FlipResult(address indexed player, uint amountWon, bool won);
  event BalanceUpdated(address user, uint transferredAmt, uint newContractBalance);


  // Constructors and Modifiers :
  constructor() public {
    provable_setProof(proofType_Ledger);
    contractBalance = 0;
    contractOwner = msg.sender;
    }

  modifier onlyOwner() {
      require(msg.sender == contractOwner, "You are not the owner");
      _;
  }


  //addresses and other such state Variables:
  address public contractOwner;
  uint private contractBalance;
  address public contractAddress;
  uint private constant NUM_RANDOM_BYTES_REQUESTED = 1;

    struct Temp {
      bytes32 id;
      address playerAddress;
    }

    struct PlayerByAddress {
      address playerAddress;
      uint playerBalance;
      bool inGame;
      uint betAmount;
    }

    mapping(bytes32 => Temp) public temps;
    mapping(address => PlayerByAddress) public playersByAddress;

    //Flip the Coin and check whether user won or lost;
    function flipCoin() public payable  {
        require(msg.value <= getBalance() && msg.value > 0, "The contract doesnt have enough balance to play right now. Come Back later");
        require(_isPlaying(msg.sender) == false, "The User currently is in Game");

        playersByAddress[msg.sender].playerAddress = msg.sender;
        playersByAddress[msg.sender].betAmount = msg.value.sub(provable_getPrice("random")); // Contract keeps oracle's fee.
        playersByAddress[msg.sender].inGame = true;



        _update();
    }



      // @dev               Calls the oracle random function.
      //                    Sets Temp for the given player.
      function _update() internal {
        uint QUERY_EXECUTION_DELAY = 0;
        uint GAS_FOR_CALLBACK =200000;
        bytes32 query_id = provable_newRandomDSQuery(QUERY_EXECUTION_DELAY, NUM_RANDOM_BYTES_REQUESTED, GAS_FOR_CALLBACK);

        temps[query_id].id = query_id;
        temps[query_id].playerAddress = msg.sender;

        emit LogNewProvableQuery(msg.sender);
      }

      // @dev               The callback function called by the oracle once the random number is created.
      // @param _queryId    The query unique identifier that is the key to the player Temp.
      // @param _result     The random number generated by the oracle.
      // @param _proof      Used to check if the result has been tampered.
      function __callback(bytes32 _queryId, string memory _result, bytes memory _proof) public {
        require(msg.sender == provable_cbAddress());

        if (provable_randomDS_proofVerify__returnCode(_queryId, _result, _proof) == 0){
          uint randomNumber = uint(keccak256(abi.encodePacked(_result)))%2;
          _verifyResult (randomNumber, _queryId);
          emit RandomNumberGenerated(randomNumber);

        }
      }


      function _verifyResult(uint _randomNumber, bytes32 _queryId) internal {
        address player = temps[_queryId].playerAddress;
        if(_randomNumber == 1){
          playersByAddress[player].playerBalance += playersByAddress[player].betAmount;
          emit FlipResult(player, playersByAddress[player].betAmount, true);
        }
        else {
          contractBalance = contractBalance.add(playersByAddress[player].betAmount);
          emit FlipResult(player,0, false );
        }

        delete(temps[_queryId]);
        playersByAddress[player].betAmount = 0;
        playersByAddress[player].inGame = false;
      }

    // Get Contract's Balance:
    function getBalance() internal view returns(uint) {
      return contractBalance;
    }

    // Get Player's Balance:
    function getPlayerBalance() public view returns (uint) {
        return playersByAddress[msg.sender].playerBalance;
      }


    // withdraw all funds possible only though contractOwner address;
    function withdrawAll() internal onlyOwner {

        uint amt = contractBalance;
        contractBalance = 0;
        
        msg.sender.transfer(amt);
        emit BalanceUpdated(msg.sender, amt, contractBalance);

    }


    //Withdraw Funds Deposited/ Won from the contract (possible for all Players of the bettingDapp Game)
    function withdrawFunds() public {
      require(msg.sender != address(0));
      require(playersByAddress[msg.sender].playerBalance > 0);
      require(!_isPlaying(msg.sender));

      uint amt = playersByAddress[msg.sender].playerBalance;
      delete(playersByAddress[msg.sender]);
      msg.sender.transfer(amt);
      emit BalanceUpdated(msg.sender, amt, contractBalance);
    }





    function fundContract() public payable {
        require(msg.value != 0);
        contractBalance = contractBalance.add(msg.value);
        emit BalanceUpdated(msg.sender, msg.value, contractBalance);

    }



    function _isPlaying(address _player) internal view returns(bool){
      _player = msg.sender;
      return playersByAddress[_player].inGame;
    }
}

